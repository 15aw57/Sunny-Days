---
title: "data_setup"
author: "Micah GVI"
date: "04/03/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r package load, warning=FALSE, message=FALSE}
# Load required libraries.
library(BiocManager)
library(annotate)
library(ape)
library(ggtree)
library(seqinr)
library(Biostrings)
library(wesanderson)
library(viridis)
library(ggplot2)
library(stringi)
library(treeio)
library(reshape2)
library(phytools)
library(mapdata)
```

```{r data import, echo=FALSE}
# Data import.
seq <- readAAStringSet("./input/master_aa_seqs.fa") # Upload data file.
seqDF <- data.frame(seq) # Convert dataset to a data frame object.
names(seqDF) <- c("seq") # IDK 
```


```{r adding missing information}
## Isolate sequence descriptions (e.g. sequence titles) and export to a csv file so that missing vector/country information can be added. 

title <- rownames(seqDF) # Create object of dataframe sequence titles (e.g. the row names of the object seqDF).
title <- as.data.frame(title) # Convert object to a data frame. 
write.csv(names, "./input/title.csv", row.names=FALSE) # Export sequence titles to csv file.

# Missing vector and country information was added to the csv file using accession literature. File was resaved under the name "titlefinal".

WNV_Variant<- read.csv("./input/titlefinal.csv") # Importing file with previously missing information added in.
seqDF <- cbind("WNVVariant" = WNV_Variant, seqDF) # Combine sequence descriptions (e.g. sequence titles) from titlefinal file with the sequence information (e.g. amino acid sequences) from the original dataframe object. 
rownames(seqDF) <- seqDF[,1] # Identify the row names of the dataset object as the information in the first column (sequence headers).
```


```{r data cleanup}
## To check the quality of the data and remove any abberant sequences, we checked the lengths of the sequences in the dataset and removed the few outliers that were drastically different from the rest.
# Check sequence lengths.
SeqLen<-as.numeric(lapply(seqDF$seq,nchar)) # Create an object containing the length of each sequence in the dataset.
qplot(SeqLen, binwidth = 50)+theme_bw() # Generate a bar graph of sequence lengths. There are nine sequences that are drastically different lengths than the rest; most sequences are ~3400 amino acids in length, with a few being under 3000 amino acids in length. I will remove these abberrant sequences:
KeepSeq<-SeqLen>3000 # Keep anything greater than 3000 in length. 
seqDF<-seqDF[KeepSeq,] # Creating a new dataset object with only sequences over 3000 amino acids long. 
```


```{r isolating structural proteins}
## To isolate the structural proteins from the full length polyprotein amino acid sequences, we used substr() and the known protein cleavage sites. We then converted each amino acid sequence into an AAbin object in preparation for a MUSCLE analysis. 
cpro_seq<- unlist(substr(seqDF$seq, start = 6, stop = 123)) # The C protein is cleaved at sites 6 and 123.
cproAA<-sapply(cpro_seq,strsplit,split="") # Put each amino acid into its own cell in preparation for conversion to an AAbin object.
names(cproAA) <- seqDF$Title # Assign sequence titles as the names of each sequence. 
cproAA <- as.AAbin(cproAA) # Convert C protein dataset to an AAbin object.


prMpro_seq <- unlist(substr(seqDF$seq, start = 217, stop = 290)) # The prM protein is cleaved at sites 217 and 290.
prMproAA<-sapply(prMpro_seq,strsplit,split="") # Put each amino acid into its own cell in preparation for conversion to an AAbin object.
names(prMproAA) <- seqDF$Title # Assign sequence titles as the names of each sequence. 
prMproAA <- as.AAbin(prMproAA) # Convert prM protein dataset to an AAbin object.


epro_seq <- unlist(substr(seqDF$seq, start = 598, stop = 791)) # The E protein is cleaved at sites 598 and 791.
eproAA<-sapply(epro_seq,strsplit,split="") # Put each amino acid into its own cell in preparation for conversion to an AAbin object.
names(eproAA) <- seqDF$Title # Assign sequence titles as the names of each sequence. 
eproAA <- as.AAbin(eproAA) # Convert E protein dataset to an AAbin object.
```

  
### Function for Alignment and Distance Matrices
```{r distance matrix function} 
DMfunction <- function(protein) {
  align<-muscle(protein,quiet=F)
  
  alignmentvisual <- image.AAbin(align, bg = (wes_palette("Darjeeling1")[5]), col = wes_palette("Darjeeling1"), ylab = "WNV Variants", xlab = "Sequence Length", show.labels = T, cex.lab = 0.2, legend = T, aa.cex = 0.8)
    DM<-dist.aa(align) # generate distance matrix based on AA sequences.
 }
```

Run the function to align sequences and create a DM object 
```{r}
CproDM <- DMfunction(cproAA)
prMproDM <- DMfunction(prMproAA)
eproDM <- DMfunction(eproAA)
```

###Function to visualize Distance Matrix 
```{r}
MatrixFunction <- function(DM) {
  DMmat<-as.matrix(DM) # convert to matrix format
  
# Melt to a linear matrix and generate distance matrix visual.
DMlmat<-melt(DMmat) # Linear matrix.
ggplot(data=DMlmat,aes(x=Var1,y=Var2,fill=value)) + geom_tile() + scale_fill_gradientn(colours=c("white","blue","green","red")) + theme(text = element_text(size=5),
        axis.text.x = element_text(angle=90, hjust=1)) + ggtitle("C Protein Distance Matrix")
}
```

```{r}
MatrixFunction(CproDM)
MatrixFunction(prMproDM)
MatrixFunction(eproDM)
```

## Group Vector Information and create Phylogeny

### Create a function to make a phylogenetic tree for proteins 
```{r}
# this functions takes in the protein for the tree to be created and whether it should create a phylogenetic tree for country or vector 

treefunction <- function(tree, type) {
  PhyloTree<- nj(tree)
  
  country = stri_extract_all(PhyloTree$tip.label, regex= "USA|Australia|South Africa|Israel|Russia|India|Madagascar|Azerbaijan|Ukraine|Czech Republic|Kenya|Nigeria|Central African Republic|DRC|Portugal|Morocco|Senegal|Tunisia|Cyprus|Japan|France", mode = "all", simplify =TRUE)  

  vect = stri_extract_all(PhyloTree$tip.label, regex= "Culex|Other|Equus|Homo sapiens|Corvus|Culiseta|Ornithodoros|Mus|Hyalomma|Oriolus|Aves|Dermacentor|Aedes|Rousettus|Culicidae",mode = "all", simplify =TRUE) 

if (type == "country"){
Groups = split(PhyloTree$tip.label, country) #Separate country from strain name
}
else if (type == "vect"){
Groups = split(PhyloTree$tip.label, vect) #Separate vector from strain name
}
col = groupOTU(PhyloTree,Groups) #Creates a group
ggtree(col, layout="rectangular", aes(color = group))#creates tree  
}

```

Using the phylogeny function we can create phylogenetic trees for the protein and method we select 
```{r}
#c protein trees
treefunction(CproDM, "country")
treefunction(CproDM, "vect")

#prM protein trees
treefunction(prMproDM, "country")
treefunction(prMproDM, "vect")

#e protein trees 
treefunction(eproDM, "country")
treefunction(eproDM, "vect")
```

```{r}
Cworld = read.csv("./input/Ccoord.csv")
rownames(Cworld) = Cworld[,1]
Cworld = subset(Cworld, select = -name)

Tree = nj(CproDM)
Tree$tip.label = stri_extract_all(Tree$tip.label, regex = "^.{8}",mode = "all", simplify =TRUE)
Tree = phytools::midpoint.root(Tree)

 phylo.to.map(Tree, Cworld,rotate = T)
``` 







