---
title: "data_setup"
author: "Micah GVI"
date: "04/03/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r package load, warning=FALSE, message=FALSE}
# Load required libraries.
library(BiocManager)
library(annotate)
library(ape)
library(ggtree)
library(seqinr)
library(Biostrings)
library(wesanderson)
library(viridis)
library(ggplot2)
library(stringi)
library(treeio)
library(reshape2)
library(phytools)
library(mapdata)
```


## Initial data import and set up. ##
```{r data import, echo=FALSE}
## Data import.
seq <- readAAStringSet("./input/master_aa_seqs.fa") # Upload fasta file containing the polyprotein amino acid sequences of 104 isolates of West Nile Virus.
seqDF <- data.frame(seq) # Convert fasta file to a data frame object.
names(seqDF) <- c("seq") # Assigning the column name of seqDF as "seq."
```

```{r adding missing information}
## Add missing vector/country information to sequence titles. 

title <- rownames(seqDF) # Create object containing isolated sequence titles (e.g. the row names of seqDF).
title <- as.data.frame(title) # Convert object to a data frame. 
write.csv(names, "./input/title.csv", row.names=FALSE) # Export sequence titles to csv file.

## Missing vector and country information was added to the csv file using accession literature. File was resaved under the name "titlefinal".

WNV_Variant<- read.csv("./input/titlefinal.csv") # Importing file with previously missing information added in.
seqDF <- cbind("WNVVariant" = WNV_Variant, seqDF) # Combine sequence descriptions (e.g. sequence titles) from titlefinal file with the amino acid sequence information from the original dataframe object. 
rownames(seqDF) <- seqDF[,1] # Identify the row names of the new dataset as the information in the first column (sequence headers).
```

```{r data cleanup}
## To check the quality of the data and remove any abberant sequences, we checked the lengths of the sequences in the dataset and removed the few outliers that were drastically different from the rest.

# Check sequence lengths.
SeqLen<-as.numeric(lapply(seqDF$seq,nchar)) # Create an object containing the length of each sequence in the dataset.
qplot(SeqLen, binwidth = 50)+theme_bw() # Generate a bar graph of sequence lengths. There are nine sequences that are drastically different in length from the rest; most sequences are ~3400 amino acids in length, with nine being under 3000 amino acids in length. I will remove these abberrant sequences:
KeepSeq<-SeqLen>3000 # Keep anything greater than 3000 in length. 
seqDF<-seqDF[KeepSeq,] # Create a new dataset object with only those sequences over 3000 amino acids long. 
```


## Distance matrix and MUSCLE protein analysis. ##
```{r isolating structural proteins}
## To isolate the structural proteins from the full length polyprotein amino acid sequences, we used substr() and the known protein cleavage sites. We then converted each amino acid sequence into an AAbin object in preparation for a MUSCLE analysis and distance matrix generation. 

cpro_seq<- unlist(substr(seqDF$seq, start = 6, stop = 123)) # The C protein is cleaved at sites 6 and 123.
cproAA<-sapply(cpro_seq,strsplit,split="") # Put each amino acid into its own cell in preparation for conversion to an AAbin object.
names(cproAA) <- seqDF$Title # Assign sequence titles as the names of each sequence. 
cproAA <- as.AAbin(cproAA) # Convert C protein dataset to an AAbin object.


prMpro_seq <- unlist(substr(seqDF$seq, start = 217, stop = 290)) # The prM protein is cleaved at sites 217 and 290.
prMproAA<-sapply(prMpro_seq,strsplit,split="") # Put each amino acid into its own cell in preparation for conversion to an AAbin object.
names(prMproAA) <- seqDF$Title # Assign sequence titles as the names of each sequence. 
prMproAA <- as.AAbin(prMproAA) # Convert prM protein dataset to an AAbin object.


epro_seq <- unlist(substr(seqDF$seq, start = 598, stop = 791)) # The E protein is cleaved at sites 598 and 791.
eproAA<-sapply(epro_seq,strsplit,split="") # Put each amino acid into its own cell in preparation for conversion to an AAbin object.
names(eproAA) <- seqDF$Title # Assign sequence titles as the names of each sequence. 
eproAA <- as.AAbin(eproAA) # Convert E protein dataset to an AAbin object.
```


```{r distance matrix and MUSCLE alignment function} 
## The following is a function for generating a distance matrix and conducting a MUSCLE alignment on an input amino acid sequence.
DMfunction <- function(protein) { #The function input is an amino acid sequence.
  align<-muscle(protein,quiet=F) # Run a muscle alignment on the input dataset.
  
  alignmentvisual <- image.AAbin(align, bg = (wes_palette("Darjeeling1")[5]), col = wes_palette("Darjeeling1"), ylab = "WNV Variants", xlab = "Sequence Length", show.labels = T, cex.lab = 0.2, legend = T, aa.cex = 0.8) # Generate a visual of the MUSCLE alignment.
    DM<-dist.aa(align) # Generate a distance matrix based on amino acid sequences.
 }
```


```{r run the function on the dataset for each protein}
## Running the function on the amino acid sequences for each protein will generate a MUSCLE alignment and alignment visual for each protein, and a distance matrix for each protein.
CproDM <- DMfunction(cproAA) # Run function on C protein dataset.
prMproDM <- DMfunction(prMproAA) # Run function on prM protein dataset.
eproDM <- DMfunction(eproAA) # Run function on E protein dataset.
```


```{r function to visualize the distance matrix}
# The following function will generate a distance matrix visual:
MatrixFunction <- function(DM) { # The input of the function is an object of class "dist".
  DMmat<-as.matrix(DM) # Convert object to matrix format.
  DMlmat<-melt(DMmat) # Melt to a linear matrix.
  ggplot(data=DMlmat,aes(x=Var1,y=Var2,fill=value)) + geom_tile() +     scale_fill_gradientn(colours=c("white","blue","green","red")) + theme(text = element_text(size=5),
  axis.text.x = element_text(angle=90, hjust=1)) + ggtitle("C Protein Distance Matrix") # Plot the distance matrix. 
}
```

```{r run the distance matrix visualization function on the distance matrix output for each protein}
MatrixFunction(CproDM) # Generate distance matrix visual for the C protein.
MatrixFunction(prMproDM) # Generate distance matrix visual for the prM protein.
MatrixFunction(eproDM) # Generate distance matrix visual for the E protein.
```


## Group vector information and create phylogeny ##
```{r function for phylogenetic trees}
# Function for generating a phylogenetic tree by country OR vector.

treefunction <- function(tree, type) { # The input of this function is the distance matrix data object (type dist()) and grouping type of phylogenetic tree (e.g. grouped by country or  vector).
  PhyloTree<- nj(tree) # Generate a phylogenetic tree using the Neighbour-Joining approach.
  
  country = stri_extract_all(PhyloTree$tip.label, regex= "USA|Australia|South Africa|Israel|Russia|India|Madagascar|Azerbaijan|Ukraine|Czech Republic|Kenya|Nigeria|Central African Republic|DRC|Portugal|Morocco|Senegal|Tunisia|Cyprus|Japan|France", mode = "all", simplify =TRUE)  # Object with code for extracting just the country name from the sequence titles.

  vect = stri_extract_all(PhyloTree$tip.label, regex= "Culex|Other|Equus|Homo sapiens|Corvus|Culiseta|Ornithodoros|Mus|Hyalomma|Oriolus|Aves|Dermacentor|Aedes|Rousettus|Culicidae",mode = "all", simplify =TRUE)  # Object with code for extracting just the vector name from the sequence titles. 

if (type == "country"){
Groups = split(PhyloTree$tip.label, country) # Apply the above code for extracting just the country name from sequence titles to the phylogenetic tree tip labels, if input is specified as type "country".
}
else if (type == "vect"){
Groups = split(PhyloTree$tip.label, vect) # Apply the above code for extracting just the vector name from sequence titles to the phylogenetic tree tip labels, if input is specified as type "vect".
}
col = groupOTU(PhyloTree,Groups) # Groups tree by either country or vector, depending on whether input was specified as type "country" or "vect," respectively.

ggtree(col, layout="rectangular", aes(color = group)) # Generate tree visualization in rectangular layout, coloured by whatever grouping factor was specified in the function input. 
}
```

```{r generate phylogenetic trees for each protein by vector and country}
## C protein
treefunction(CproDM, "country") # Phylogenetic tree of the C protein grouped by country where the sequence was isolated.
treefunction(CproDM, "vect") # Phylogenetic tree of the C protein grouped by vector from which the sequence was isolated.

## prM protein
treefunction(prMproDM, "country") # Phylogenetic tree of the prM protein grouped by country where the sequence was isolated.
treefunction(prMproDM, "vect") # Phylogenetic tree of the prM protein grouped by vector from which the sequence was isolated.

## E protein
treefunction(eproDM, "country") # Phylogenetic tree of the E protein grouped by country where the sequence was isolated.
treefunction(eproDM, "vect") # Phylogenetic tree of the E protein grouped by vector from which the sequence was isolated.
```

### Zooming in on interesting parts of each phylogeny
```{r}
#Create function to generate new tip labels for each tree displaying (country,year). The input of this function is a phylogenetic tree.

nametip = function(tree) {
  
#Use regex to select country out of the Tip labels
country = stri_extract_all(tree$tip.label, regex= "USA|Australia|South Africa|Israel|Russia|India|Madagascar|Azerbaijan|Ukraine|Czech Republic|Kenya|Nigeria|Central African Republic|DRC|Portugal|Morocco|Senegal|Tunisia|Cyprus|Japan|France", mode = "all", simplify =TRUE) 

#Use regex to select years out of the E Protein Tip labels
Year = stri_extract_all(tree$tip.label, regex = "\\d{4}[^\\d]*$",mode = "all", simplify =TRUE)

#Combine the years and countries together and set those values as the new tip labels (Country,Year)
name = melt(data.frame(country, Year))
name$full = paste(name$country, name$Year, sep=",")

return(name$full)
}
```

```{r warning = F, message = F}
TreeE = nj(eproDM) #Create Tree using E Protein
TreeC = nj(CproDM) #Create Tree using C Protein
TreeprM = nj(prMproDM) #Create Tree using prM protein

TreeE$tip.label = nametip(TreeE) #Assign new tip labels to each protein tree
TreeC$tip.label = nametip(TreeC)
TreeprM$tip.label = nametip(TreeprM)
```

```{r}
#Use ggtree to generate tree from E Protein
ET = ggtree(TreeE, branch.length = "none")+
  geom_tiplab(size = 2.75)+ #Decrease tip label size
  xlim(NA,60)+  #Shift phylogeny to the left
  geom_hilight(node=164, fill="gold", alpha = 0.15) + #highlight distinct groupings in phylogeny
  geom_hilight(node=145, fill="purple", alpha = 0.15)+ 
  geom_hilight(node=135, fill="blue", alpha = 0.15)

ET = ggtree::collapse(ET, node=153) #collapse clade to the right of groupings
viewClade(ET, MRCA(ET, 82, 80)) #Zoom in on interesting groupings
```

```{r}
#Use ggtree to generate tree from C Protein
CT = ggtree(TreeC, branch.length = "none")+
  geom_tiplab(size = 2.75)+ #Decrease tip label size
  xlim(NA,60)+  #Shift phylogeny to the left
  geom_hilight(node=173, fill="orange", alpha = 0.2) + #highlight distinct groupings in phylogeny
  geom_hilight(node=145, fill="pink", alpha = 0.2)+ 
  geom_hilight(node=159, fill="skyblue", alpha = 0.2)

viewClade(CT, MRCA(CT, 39, 80)) #Zoom in on interesting groupings
```

```{r}
#Use ggtree to generate tree from prM Protein
prMT = ggtree(TreeprM, branch.length = "none")+
  geom_tiplab(size = 2.75)+ #Decrease tip label size
  xlim(NA,80)+ #Shift phylogeny to the left
  geom_hilight(node=144, fill="gold", alpha = 0.15) + #highlight distinct groupings in phylogeny
  geom_hilight(node=161, fill="purple", alpha = 0.15)+ 
  geom_hilight(node=174, fill="blue", alpha = 0.15)

viewClade(prMT, MRCA(prMT, 140, 80)) #Zoom in on interesting groupings
```








